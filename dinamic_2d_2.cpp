// 1 dp[i][j] матрица в ней каждое значение элеента длина общей последовательности конкретно 
// на шаге i j тоесть в клетке i j у нас i подряд элементов с начала из первой последовательности и j подряд
// элементов с начала из второй последовательности причем наибольшей тоесть i j это одновременно и индексы своих последовательно
// стей
//  тоесть мы идем по матрице и как бы мысленно добавляем по одному элементу из исходных последовательностей идем по строке 
// тоесть просматриваем все элементы первой последовательности потом переходим к следующей строке слева направо
// в каждой клетке хранится максимальная общая подпоследовательность для конкретных случаев которые описаны выше ij
// 2 dp[0][0] = 0 более того давайте сделаем что и первая строка и первый столбец тоже будут нулями потому что 
// [i][0] и [0][j] там всегда значение клеток будет 0 потому что одна из последовательностей как бы пустая а значит нет общих
// 3 если все это обдумать то получается и ответ на вопрос как считать каждую клетку 
// давайте посмотрим вот мы дошли до клетки i j мы можем посмотреть от нее вверх налево и по диагонали влево вверх
// разберем все вот мы дошли новой клетки i j нам нужно ответить на вопрос какая общая длина для этой клетки 
// но ведь в клетках сверху слева и по диагонали влево вверх уже посчитаны длины, а в клетке который мы сейчас стоим 
// как бы мысленно представляем что есть i элементов одной последовательности и j элементов другой 
// начнем с того что посмотрим равны ли A[i]==B[j] если не равны то нет общего элемента значит эта клетка не даст прирост 
// общей последовательности значит нам вообще не важно какие там числа, но мы уже знаем что предыдущие то посчитаны
// они никуда не делись ведь мы всегда увеличиваем размер РАССМАТРИВАЕМЫХ последовательностей тоесть хоть и увеличения нет
// но предыдущие вычисления никуда не делись 
// значит мы как бы добавили один элемент из одной последовательности и один из другой они не равны 
// значит они никак не влияют на значение элемента в клетке но клетку нужно заполнить другие то элементы
// в последовательностях остались 
// ВАЖНО!!! если числа не совпадают
// нам вообще не важно какие там числа
//  нам нужно посмотреть на предыдущие вычисления(самые ближайшие)
// а самые ближайшие это слева и сверху почему не диагональ? да потому что слева и сверху когда они только
// вычислялись тоесть мы откатываемся назад они содержать max(что-то, диагональ которая не должна использоваться)
// тоесть значения слева и сверху точно не меньше значения в диагонали
// ТОЕСТЬ ВАЖНО ПОНЯТЬ что мы если A[i]==B[j] не равны то мы вообще их не берем в общую последовательность
// мы забываем про них и смотрим на предыдущие вычисления ведь задача найти общие 
// мы смотрим на предыдущие вычисления ближайшие а это либо без одного элемента в одной последова
// тельности либо без одного элемента в другой ДРУГИЕ ВХОДЯТ В ЭТИ (которые слева и сверху)
// ну и давайте просто выберем наибольшую длину из предыдущих БЛИЖАЙШИХ вычислений это и будет
// длиной для данных двух последовательностей 
//Поскольку текущие элементы разные, они не могут одновременно войти в конец общей подпоследовательности.
//Это значит, что для нахождения LCS в этой точке мы можем рассмотреть любую из двух ближайших уже 
//решённых подзадач :
//без последнего элемента в A(dp[i - 1][j]),
//или без последнего элемента в B(dp[i][j - 1]).
//Какой именно из этих элементов «не участвует» — неважно, потому что в текущем шаге они всё равно 
//не влияют на длину LCS.Мы просто берём максимум из этих двух значений, чтобы сохранить наибольшую 
//найденную длину.
//******
// а если элементы равны мы ищем максимум между 
//  (берем предыдущую задачу без этих элементов и прибавляем единицу) и (максимум между левой и верхней) 
// тоесть может быть что максимальная длина была больше без даже совпадения поэтому так
// 4 обход по строкам сверху вниз и по столбцам слева направо 
// 5 ответ в самой нижней правой клетке 
// 
// 6
// 1 2 3 4 9 8 
// 6
// 1 5 4 6 8 10 

#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    int n;
    std::cin >> n;
    std::vector<int> A(n + 1);
    for (int i = 1; i <= n; i++) std::cin >> A[i];

    int m;
    std::cin >> m;
    std::vector<int> B(m + 1);
    for (int j = 1; j <= m; j++) std::cin >> B[j];

    std::vector<std::vector<int>> table(n + 1, std::vector<int>(m + 1, 0));

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            table[i][j] = std::max(table[i - 1][j], table[i][j - 1]);
            if (A[i] == B[j]) {
                table[i][j] = std::max(table[i][j], table[i - 1][j - 1] + 1);
            }
        }
    }

    int i = n, j = m;
    std::vector<int> idxA; 
    std::vector<int> idxB; 

    while (i > 0 && j > 0) {
        if (A[i] == B[j] && table[i][j] == table[i - 1][j - 1] + 1) {
            idxA.push_back(i);
            idxB.push_back(j);
            i--; j--;
        }
        else if (table[i - 1][j] >= table[i][j - 1]) {
            i--;
        }
        else {
            j--;
        }
    }


    std::reverse(idxA.begin(), idxA.end());
    std::reverse(idxB.begin(), idxB.end());


    std::cout << "LCS length = " << table[n][m] << "\n";
    std::cout << "Indices in A: ";
    for (int id : idxA) std::cout << id << " ";
    std::cout << "\nIndices in B: ";
    for (int id : idxB) std::cout << id << " ";
    std::cout << "\n";

    return 0;
}

