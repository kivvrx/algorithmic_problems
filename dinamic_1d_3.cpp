//1 dp[i] - каждое хранит количество способов добраться до ступеньки i
//2 базовый случай dp[0] = 0 и сказано что мы уже на первой ступеньке значит dp[1] = 1
//3 допустим нам надо попасть на вторую ступеньку мы начинаем с первой значит dp[2] = 1 тоесть чтобы попасть
// с первой на вторую можно сделать только один прыжок (а мы начинаем с первой ступеньки по условию задачи)
// далее чтобы попасть на третью ступеньку с первой можно прыгнуть на 2 или по 1 разу шагать с 1 на 2 и с 2 на 3
// получается чтобы попасть на третью ступеньку нужно dp[3] = dp[2] + dp[1] тоесть получается тут 
// имеется ввиду прыжок с длиной 2 + прыжок с длиной 1 
//Как можно оказаться на 3‑й ступеньке ?
//Вариант 1 : Последний прыжок был с 2‑й ступеньки.Чтобы попасть на 2‑ю, у нас есть ровно dp[2] 
//способов(мы их уже посчитали раньше).Каждый из этих способов можно продолжить одним прыжком 
//на 3‑ю.Значит, через 2‑ю ступеньку мы получаем ровно dp[2] способов на 3‑ю.
//Вариант 2 : Последний прыжок был с 1‑й ступеньки.Чтобы попасть на 1‑ю, у нас есть dp[1] способов
//(в начале мы уже на ней, так что dp[1] = 1).Из каждого такого способа можно сделать один прыжок длиной 
//2 на 3‑ю.Значит, через 1‑ю ступеньку мы получаем ровно dp[1] способов на 3‑ю. нельзя сделать 
// 2 прыжка с 1-ой потому что это уже обработано для 1 варианта 
// таким образом формула dp[i] = dp[i-1] + dp[i-2] корректна
// 4 порядок обхода по возратсанию
// 5 ответ записан в dp[i]
#include <iostream>
#include <vector>
using namespace std;
const int MOD = 1e9 + 7;

int main() {
    int n, k;
    cin >> n >> k;
    vector<long long> dp(n + 1, 0);
    dp[0] = 0; 
    dp[1] = 1; 

    for (int i = 2; i <= n; ++i) {
        for (int j = 1; j <= k; ++j) {
            if (i - j >= 1) {
                dp[i] = (dp[i] + dp[i - j]) % MOD;
            }
        }
    }

    cout << dp[n] % MOD << "\n";
    return 0;
}
