#include <vector>

//gcd НОД
// делимость - a/b = k => если сущесвтует целое k то делится a на b
// общий делитель это когда существует d такое что a/d и b/d без отстака
// нод g двух чисел a и b если : 1. g является общим делителем a и b 2. 
// Любой другой общий делитель d чисел a и b делит g
// Теорема о делении с остатком. Для любых целых чисел a (делимое) и b (делитель), где b > 0, существуют
// единственные целые числа q (неполное частное) и r (остаток) такие, что:
// a = b * q + r, где 0 ≤ r < b.
// Пусть a = b * q + r для некоторых целых a, b, q, r. Тогда множество общих делителей чисел a и b совпадает 
// с множеством общих делителей чисел b и r. Следовательно, gcd(a, b) = gcd(b, r).
// r это остаток  от деления остаток от деления a и b это число r = a%b 
// НОД(a, 0) = a
// НОД(a, b) = НОД(b, r = a%b)
// 1.Если b = 0, то ответ |a| (по определению, gcd(a, 0) = |a|). Алгоритм завершается.
// 2.Иначе, находим остаток r от деления a на b : r = a mod b.
// 3.Заменяем пару(a, b) на пару(b, r).
// 4.Возвращаемся к шагу 1.
// для n чисел НОД(a,b,c) = НОД(НОД(a,b),c) тоесть в качестве a выступает НОД предыдущих в качестве b
// новое число из массива чисел для проверки 
//**********************************************************************************************************************
// lcm НОК
// Число K называется кратным числу N, если существует такое целое число M, что:
// K = N × M 12 кратно 3, потому что 12 = 3 × 4
// Любое общее кратное должно содержать все простые множители обоих чисел
// НОД содержит общие простые множители
// При умножении a* b общие множители учитываются дважды
// Деление на НОД убирает это дублирование
// НОК(a, b) = |a * b| / НОД(a, b)
//Возьмём a = 12, b = 18:
//Разложим на множители :
//12 = 2^2 × 3
//18 = 2 × 3^2
//НОД содержит общие множители в минимальных степенях :
//НОД(12, 18) = 2^1 × 3^1 = 6
//НОК содержит все множители в максимальных степенях :
//НОК(12, 18) = 2^2 × 3^2 = 36
//Проверим формулу :
//| 12 × 18| / НОД(12, 18) = 216 / 6 = 36


int gcd_recursive(int a, int b) {
	return b == 0? a : gcd_recursive(b, a%b);
}
int gcd_itarate(int a, int b) {
	while (b != 0) {
		int r = a % b;
		a = b;
		b = r;
	}
	return a;
}

int gcd_vector(const std::vector<int>& numbers) {
	if (numbers.empty()) return 0;

	int result = numbers[0];
	for (size_t i = 1; i < numbers.size(); i++) {
		result = gcd_recursive(result, numbers[i]);
		if (result == 1) break;
	}
	return result;
}

int lcm_recursive(int a, int b) {
	if (a == 0 || b == 0) return 0;
	return abs(a * b) / gcd_recursive(a, b);
}

int lcm_vector(const std::vector<int>& numbers) {
	if (numbers.empty()) return 1;
	int result = numbers[0];
	for (size_t i = 1; i < numbers.size(); i++) {
		result = lcm_recursive(result, numbers[i]);
	}
	return result;
}

int main() {
	
	return 0;
}