#include <iostream>
#include <vector>

// так как гарантируется что искомая последовательность существует, ключевая идея в том что 
// 1. если мы из общей суммы элементов до удаления одного отнимем общую сумму после мы получим 
// значение удаленного элемента. 
// 2. теперь когда мы узнали значение удаленного элемента будем работать с n-1 кубиками
// я решил делить общую сумму после удаления одного элемента на число оставшихся элементов 
// так как в c++ округление при целочисленном делении происходит вниз тоесть например 15/4 = 3
// хотя это 3.75 тоесть это не математическое округление, а значит мы каждый раз при делении ищем 
// минимальное число на кубике которое равномерно распределено между оставшимися 
// и далее на каждом шаге мы отнимаем из общей суммы это число на кубике и отнимаем 
// от общего числа кубиков один (ведь мы его уже записали его значение)
// таким образом на каждом шаге всегда ищется равномерное число между оставшимися кубиками 

int main() {
    int t;
    std::cin >> t;

    std::vector<std::vector<int>> n_s_r(t, std::vector<int>(3));

    for (int i = 0; i < t; ++i) {
        for (int j = 0; j < 3; ++j) {
            std::cin >> n_s_r[i][j];
        }
    }

    std::vector<std::vector<int>> ans(t);

    for (int i = 0; i < t; ++i) {
        int n = n_s_r[i][0];
        int s = n_s_r[i][1];
        int r = n_s_r[i][2];

        int removed = s - r;
        ans[i].push_back(removed);

        int remaining = n - 1;
        int current_r = r;

        for (int j = 0; j < remaining; ++j) {
            int available = remaining - j;
            int elem = current_r / available;
            ans[i].push_back(elem);
            current_r -= elem;
        }
    }

    for (const auto& vec : ans) {
        for (int val : vec) {
            std::cout << val << ' ';
        }
        std::cout << std::endl;
    }

    return 0;
}